from bcc import BPF
from bcc.utils import printb
from time import sleep

bpf_text = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>

struct key_t {
    u32 pid;
    char comm[TASK_COMM_LEN];
};
BPF_HASH(execve_syscall_ctr, struct key_t, u64);

TRACEPOINT_PROBE(syscalls, sys_enter_execve){
    u64 tgid = bpf_get_current_pid_tgid() >> 32;
    struct key_t key = {.pid = tgid};
    u64 zero = 0, *val;
    bpf_get_current_comm(&key.comm, sizeof(key.comm));
    val = execve_syscall_ctr.lookup_or_init(&key, &zero );
    *val = *val + 1;
    return 0;
};
"""

if __name__ == '__main__':
    # check whether hash table batch ops is supported
    htab_batch_ops = True if BPF.kernel_struct_has_field(b'bpf_map_ops',b'map_lookup_and_delete_batch') == 1 else False
    b = BPF(text=bpf_text)
    print("Profiling execve... Hit Ctrl-C to end.")
    try:
        sleep(99999999)
    except KeyboardInterrupt:
        execve_syscall_ctr = b.get_table("execve_syscall_ctr")
        for k, v in execve_syscall_ctr.items():
            print("%-16s %-7d %d" % (k.comm, k.pid, v.value))

# libtraceevent1